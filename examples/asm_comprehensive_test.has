// Comprehensive @varname substitution test with edge cases

code comprehensive:

// Test 1: Multiple parameters and locals
proc test1(a: int, b: int, c: int) -> long {
    var x: long = 1;
    var y: long = 2;
    var z: long = 0;
    
    asm {
        move.l @a,d0
        move.l @b,d1
        move.l @c,d2
        move.l @x,d3
        move.l @y,d4
        add.l d1,d0
        add.l d2,d0
        add.l d3,d0
        add.l d4,d0
        move.l d0,@z
    }
    
    return z;
}

// Test 2: Multiple references to same variable
proc test2(param: long) -> long {
    var local: long = 0;
    
    asm {
        move.l @param,d0      // First reference
        move.l @param,d1      // Second reference
        move.l @param,d2      // Third reference
        add.l d1,d0
        add.l d2,d0
        move.l d0,@local      // Write to local
        move.l @local,d0      // Read back from local
    }
    
    return local;
}

// Test 3: Mixed asm with comments (comments should be preserved)
proc test3(val: int) -> int {
    var result: int = 0;
    
    asm {
        // Load the parameter value
        move.l @val,d0        ; Get param
        
        // Double it
        add.l d0,d0           ; Double in d0
        
        // Store result
        move.l d0,@result     ; Write result
    }
    
    return result;
}

// Test 4: Register-like local names that don't clash
proc test4() -> long {
    var d0_val: long = 100;
    var a0_val: long = 200;
    var result: long = 0;
    
    asm {
        move.l @d0_val,d0
        move.l @a0_val,d1
        add.l d1,d0
        move.l d0,@result
    }
    
    return result;
}

// Test 5: Pointer parameters
proc test5(ptr_param: ptr, value: long) -> long {
    var local_ptr: ptr = 0;
    
    asm {
        move.l @ptr_param,a0
        move.l @value,d0
        move.l d0,(a0)          ; Dereference pointer
        move.l @ptr_param,@local_ptr
    }
    
    return value;
}
