// Example using high-assembler prototype

code s:
    asm {
        jmp start
    }

// Data section with initialized variables
data my_data:
    my_counter = 100          // default is .l (long/32-bit)
    status_byte.b[10] = 1         // byte (8-bit)
    frame_count.w = 0         // word (16-bit)
    screen_ptr.l = 14680064   // long (32-bit) - explicit
    nums.l = 1
    nums2.l = 2
    nums3.l = 3
    nums4.l = 10
    txt.b = "test",1,3

// BSS section with uninitialized variables
bss my_bss:
    buffer: 64
    bbuf.b[100]


code main:
    proc add(a: int, b: int) -> int {
        // High-level: return sum of a and b
        var ret:int = 0;
        var ptr:byte* = &txt;

        for i = 0 to 10
        {
            ret = status_byte[i];
        }
        return a + b + ret;
    }

    proc add_reg(__reg(d0) a: int, __reg(d1) b: int) -> int {
        // Register-based: parameters passed in d0 and d1
        return a + b;
    }

    proc add_mixed(__reg(d0) a: int, b: int) -> int {
        // Mixed: first param in d0, second on stack
        var t:word;
        t = 100;
        repeat 10
        {
            t = t +10;
            if(t>5)
            {
                break;
            }
        }
        return a + b * t;
    }

    // Raw assembler block at top-level (using brace-style asm block)
    asm {
start:
    jsr add
    rts
    }

    proc caller() -> int {
        // Stack-based call: push args and caller cleans up
        var e: int = 20;
        var ptr: long* = 40000;

        *ptr = $1000;
        if (*ptr & %11111111 == 0)
        {
            asm "nop"
        }
        if (add(3, e) - 3) {
            PUSH(d0,a6);
            asm {
                rts
            }
            POP();
        }

        // Call the register-based version (caller still pushes to stack, but callee reads from regs)
        call add_reg(5, 6);

        return 0;
    }

    asm {
    jsr caller
    }
